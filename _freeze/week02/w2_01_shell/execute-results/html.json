{
  "hash": "25ab5e30bd46f28cde96e74f95575e8b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Unix Shell Basics\"\npagetitle: \"PRACS25: Shell Basics\"\nauthor: Jelmer Poelstra\ndate: 2025-09-02\neditor_options: \n  chunk_output_type: console\n---\n\n\n\n--------------------------------------------------------------------------------\n\n<br>\n\n### Overview {-}\n\nIn this week's sessions,\nwe'll cover much of [CSB](https://library.ohio-state.edu/record=b8624007~S7)'s\nChapter 1 to learn:\n\n- Why using a command-line interface can be beneficial.\n- What the Unix shell is and what you can do with it. \n- Using the shell, how to:\n  - Navigate around your computer.\n  - Create and manage folders and files.\n  - View text files.\n  - Search within, manipulate, and extract information from text files.\n\n::: callout-tip\n#### See the [\"Topic Overview\" page on the Unix shell](../ref/shell.qmd) for an overview of shell commands we'll cover during this course.\n:::\n\n<br>\n\n## Introduction to Unix and the Unix Shell\n\n### Some terminology and concepts\n\n#### Unix (vs. Linux)\n\nWe can conceptualize Unix (or \"Unix-like\" / \"Unix-based\")^[\n_Technically_, the latter terms are more correct,\nas Unix formally does refer to a specific operating system.]\nas a **family of operating systems**, which includes Linux and Mac but not Windows.\n\nFor scientific computing, Unix-based operating systems are generally preferable.\nSupercomputers, like the Ohio Supercomputer Center (OSC), use Linux.\nIn this course, though, your laptop/desktop can run on any operating system,\nprecisely because we will connect to OSC and do our work there.\n\n#### Unix shell-related terms\n\n-   **Command Line** and **Command Line Interface (CLI)** — A user interface where you type commands\n-   **Shell** — a more specific and technical term for a command line interface _to your computer_\n-   **Unix Shell** — the type of shell on Unix-based (Linux + Mac) computers\n-   **Bash** — the specific Unix shell _language_ that is most common\n-   **Terminal** — the program/app/window that can run a shell\n\nWhile these are clearly not synonyms, in day-to-day computing,\nthey are often used interchangeably.\n\n::: callout-note\n#### CLI vs. GUI\nInstead of a Command-line Interface (CLI),\nmost programs that we use on a day-to-day basis have a Graphical User Interface (GUI),\nwhich are operated mostly by pointing and clicking rather than typing.\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Why use the Unix shell?\n\nThe Unix shell has been around for a long time and can sometimes seem a bit\narchaic.\nBut astonishingly, a system largely built decades ago in an era with very\ndifferent computers and datasets has stood the test of time,\nand the ability to use it is a crucial skill in applied bioinformatics.\n\nSpecifically, you may want to or need to use the Unix shell as opposed to\nprograms with Graphical User Interfaces (GUIs) because of:\n\n- **Software needs**\\\n  When working with omics data, we don't code our entire analysis from scratch --\n  for example, we don't build our own genome assembly or read alignment algorithm.\n  Many of the external tools that we use for this are run in the shell with\n  a Command-Line Interface (CLI).\n- **Automation and fewer errors**\\\n  The shell allows you to repeat and automate tasks easily and without\n  introducing errors.\n- **Reproducibility**\\\n  It's more straightforward to keep a detailed record of what you have done.\n- **Working with large files**\\\n  Shell commands are really good at processing _large, plain-text files_,\n  which are very common in omics data.\n- **Remote computing – especially supercomputers**\\\n  It is often only possible to work in a shell when doing remote computing.\n\nBut what about versus other coding languages?\nWhy do we need to know the Unix shell on top of R and/or Python?\n\n- **Efficiency**\\\n  For many _simpler_ tasks, built-in shell tools are faster ---\n  in terms of coding time, processing time,\n  and the ease of working with very large files.\n- **Running external software**\\\n  As mentioned above,\n  we need to use many external programs with a CLI in omics data analysis.\n  While those _can_ be called from within other languages,\n  the shell has a _direct_ interface to them and is therefore often preferred.\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### The Unix directory structure\n\n- \"Directory\" (or \"**dir**\" for short) is the term for *folder* that is commonly\n  used in Unix contexts.\n    \n- The Unix directory structure is _hierarchical_,\n  with a single starting point: the **root**, depicted as **`/`**.\n\n- A \"**path**\" gives the location of a file or directory, in which directories\n  are separated by forward slashes `/`.\n    \n- So: a leading `/` in a path is the root dir,\n  and any subsequent `/` are used to separate dirs.\n  For example, the path to our OSC project's dir is `/fs/ess/PAS2880`.\n  This means: the dir `PAS2880` is located inside the dir `ess`, which in turn is\n  inside the dir `fs`, which in turn is in the computer's root directory.\n\n- The OSC dir structure is somewhat different from that of a personal computer.\n  Our Home dir is not `/home/<username>` like in the book and the schematic\n  on the left, but `/users/PASXXXX/<username>`.\n\n::: columns\n::: column\n![Generic computer dir structure, from [O'Neil 2017](https://open.oregonstate.education/computationalbiology/chapter/the-command-line-and-filesystem/)](img/oneil_filesystem_ex2.png){fig-align=\"center\" width=\"95%\"}\n:::\n::: column\n![Key dirs in the OSC dir structure](img/osc_dirstructure.png){fig-align=\"center\" width=\"89%\"}\n:::\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: exercise\n#### {{< fa user-edit >}} Exercise: Figure out the path\n\nIn the above schematic on the left, what is the path to the file `todo_list.txt`?\n\n<details><summary>Solution</summary>\n\nThe path to the file `todo_list.txt` is:\n`/home/oneils/documents/todo_list.txt`\n\n</details>\n:::\n\n<br>\n\n## First steps in the shell\n\n### Accessing a shell at OSC\n\n1.  Go to <https://ondemand.osc.edu> in your browser, and log in.\n2.  Click on the `Clusters` dropdown menu in the top bar and select\n    `Cardinal Shell Access`.\n\n### The shell's prompt\n\nInside your terminal, the \"prompt\" indicates that the shell is ready for a\ncommand. What is shown exactly varies across shells and can also be customized,\nbut our prompts at OSC should show the following information:\n\n`<username>@<node-name> <working-dir>]$`\n\nFor example (and _note that **`~`** means your Home dir_):\n\n``` bash-in-nocolor\n[jelmer@cardinal-login02 ~]$ \n```\n\nWe type our commands after the dollar sign `$`,\nand then press <kbd>Enter</kbd> to execute the command.\nWhen the command has finished executing,\nwe'll get our prompt back and are able to type and execute a new command.\n\n::: callout-tip\n#### Clear the screen with <kbd>Ctrl</kbd>+<kbd>L</kbd>\nOSC prints welcome messages and storage quota information when you open a shell.\nTo reduce the amount of text on the screen, I will **clear** the screen now and regularly throughout.\nThis can be done with the keyboard shortcut **<kbd>Ctrl</kbd>+<kbd>L</kbd>**.\n\nThis is the first of a number of keyboard shortcuts you will learn,\nas these are very useful when working in the shell.\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### A few simple commands: `date` and `pwd`\n\nThe Unix shell comes with hundreds of \"commands\":\nsmall programs that perform specific actions.\n(If you're familiar with R or Python, a Unix *command* is like an R/Python *function*.)\n\nLet's start with a few simple commands:\n\n-   The `date` command prints the current date and time:\n\n    ``` bash\n    date\n    ```\n    ``` bash-out\n    Thu Feb 29 14:58:19 EST 2024\n    ```\n\n-   The `pwd` (Print Working Directory) command prints the path to the directory\n    you are currently located in:\n\n    ``` bash\n    pwd\n    ```\n    ``` bash-out\n    /users/PAS0471/jelmer\n    ```\n\nBoth of those commands provided us with some output. That output was **printed\nto screen**, which is the default behavior for nearly every Unix command.\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: callout-warning\n#### Copying and pasting in this shell\n\nYou can't right-click in this shell, so to copy-and-paste:\n\n-   **Copy** simply by selecting text\n    (you should see a copy ({{< fa copy >}}) icon appear).\n-   **Paste** using <kbd>Ctrl</kbd>+<kbd>V</kbd>.\n\n{{< fa user-edit >}} Try copying and pasting a random word into your shell.\nThis may just work, you may get a permission pop-up, or it may silently fail ---\nif the latter, click on the clipboard icon in your browser's address bar\n(see red circle in screenshot below):\n\n![](img/pasting2.png)\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n## Options, arguments, and help\n\n### The `cal` command --- and options & arguments\n\nThe `cal` command is another example of a command that simply prints some\ninformation to the screen, in this case a calendar.\nWe'll use it to learn about command *options* and *arguments*.\n\nInvoking `cal` without options or arguments will show a calendar for the current month:\n\n```bash\ncal\n```\n``` bash-out\n    February 2024   \nSu Mo Tu We Th Fr Sa\n             1  2  3\n 4  5  6  7  8  9 10\n11 12 13 14 15 16 17\n18 19 20 21 22 23 24\n25 26 27 28 29\n```\n\n#### Option examples\n\nUse the *option* `-j` (a dash `-` and then `j`) to instead get a Julian calendar,\nin which day numbering is continuous instead of restarting each month:\n\n```bash\n# Make sure to leave a space between `cal` and `-j`!\ncal -j\n```\n```bash-out\n       February 2024       \nSun Mon Tue Wed Thu Fri Sat\n                 32  33  34\n 35  36  37  38  39  40  41\n 42  43  44  45  46  47  48\n 49  50  51  52  53  54  55\n 56  57  58  59  60\n```\n\nUse the `-3` option to show 3 months (adding the previous and next month):\n\n```bash\ncal -3\n```\n``` bash-out\n    January 2024          February 2024          March 2024     \nSu Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa\n    1  2  3  4  5  6               1  2  3                  1  2\n 7  8  9 10 11 12 13   4  5  6  7  8  9 10   3  4  5  6  7  8  9\n14 15 16 17 18 19 20  11 12 13 14 15 16 17  10 11 12 13 14 15 16\n21 22 23 24 25 26 27  18 19 20 21 22 23 24  17 18 19 20 21 22 23\n28 29 30 31           25 26 27 28 29        24 25 26 27 28 29 30\n                                            31   \n```\n\nWe can combine multiple options -- for example:\n\n```bash\ncal -j -3\n```\n``` bash-out\n        January 2024                February 2024                  March 2024        \nSun Mon Tue Wed Thu Fri Sat  Sun Mon Tue Wed Thu Fri Sat  Sun Mon Tue Wed Thu Fri Sat\n      1   2   3   4   5   6                   32  33  34                       61  62\n  7   8   9  10  11  12  13   35  36  37  38  39  40  41   63  64  65  66  67  68  69\n 14  15  16  17  18  19  20   42  43  44  45  46  47  48   70  71  72  73  74  75  76\n 21  22  23  24  25  26  27   49  50  51  52  53  54  55   77  78  79  80  81  82  83\n 28  29  30  31               56  57  58  59  60           84  85  86  87  88  89  90\n                                                           91 \n```\n\nHandily, options can be \"pasted together\" like so (output not shown - same as above):\n\n```bash\ncal -j3\n```\n\n#### Options summary\n\nAs we've seen, options are specified with a dash `-`\n(or to dashes `--`, as you'll see later).\nSo far, we've only worked with the type of options that are also called \"**flags**\",\n_which change some functionality in an ON/OFF type way_:\n\n- Turning a Julian calender display ON with `-j`\n- Turning a 3-month display ON with `-3`.\n\nGenerally speaking, we can say that options **change the behavior** of a command.\n\n#### Arguments\n\nWhereas options change the behavior of a command,\narguments typically tell the command **what to operate on**.\nMost commonly, these are file or directory paths.\n\nAdmittedly, the `cal` command is not the best illustration of this pattern ---\nwhen you give it one argument, this should be the year to show a calendar for:\n\n```bash\ncal 2020\n```\n```bash-out\n                              2020                               \n\n       January               February                 March       \nSu Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa\n          1  2  3  4                      1    1  2  3  4  5  6  7\n 5  6  7  8  9 10 11    2  3  4  5  6  7  8    8  9 10 11 12 13 14\n12 13 14 15 16 17 18    9 10 11 12 13 14 15   15 16 17 18 19 20 21\n19 20 21 22 23 24 25   16 17 18 19 20 21 22   22 23 24 25 26 27 28\n26 27 28 29 30 31      23 24 25 26 27 28 29   29 30 31\n\n# [...output truncated, entire year is shown...]\n```\n\nWe'll see some examples of commands operating on files or dirs later.\nFinally, we can also _combine_ options and arguments:\n\n```bash\ncal -j 2020\n```\n```bash-out\n                            2020                          \n\n          January                       February         \nSun Mon Tue Wed Thu Fri Sat   Sun Mon Tue Wed Thu Fri Sat\n              1   2   3   4                            32\n  5   6   7   8   9  10  11    33  34  35  36  37  38  39\n 12  13  14  15  16  17  18    40  41  42  43  44  45  46\n 19  20  21  22  23  24  25    47  48  49  50  51  52  53\n 26  27  28  29  30  31        54  55  56  57  58  59  60\n \n# [...output truncated, entire year is shown...]\n```\n  \nTo summarize, different from options, _arguments_ to a command:\n\n- Are not preceded by a `-` (or `--`)\n- If options and arguments are combined, arguments **come after** options^[\n  Though some commands are flexible and accept either order.].\n\n::: callout-warning\n#### TBA: Command structure visualization\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Getting help\n\nMany basic Unix commands – *and other command-line programs!* –\nhave a **`-h`** option for help,\nwhich usually gives a concise summary of the command's \"syntax\",\ni.e. its available options and arguments:\n\n```bash\ncal -h\n```\n```bash-out\n\nUsage:\n cal [options] [[[day] month] year]\n\nOptions:\n -1, --one        show only current month (default)\n -3, --three      show previous, current and next month\n -s, --sunday     Sunday as first day of week\n -m, --monday     Monday as first day of week\n -j, --julian     output Julian dates\n -y, --year       show whole current year\n -V, --version    display version information and exit\n -h, --help       display this help text and exit\n```\n\nIn this case, each option can be referred to in two ways:\n\n- A short-form notation: a single dash followed by a single character (e.g. `-s`)\n- A long-form notation: two dashes followed by a word (e.g. `--sunday`)\n\n::: {.callout-note collapse=\"true\"}\n### Another way to see documentation: the `man` command _(Click to expand)_\nAn alternative way of getting help for Unix commands is with the `man` command:\n\n```bash\nman cal\n```\n\nThis manual page often includes a lot more details than the `--help` output,\nand it is opened inside a \"pager\" rather than printed to screen:\ntype **<kbd>q</kbd>** to exit the pager that `man` launches.\n\n:::\n\n::: exercise\n#### {{< fa user-edit >}} Exercise: Interpreting the help output\n\n- Look through the options listed when you ran `cal -h`, and try an option we\n  haven't used yet.\n  (You can also combine this new option with other options, if you want.)\n\n<details><summary>Solution</summary>\n\n```bash\n# Print a calendar with Monday as the first day of th week (instead of the default, Sunday) \ncal -m\n```\n```bash-out\n    February 2024   \nMo Tu We Th Fr Sa Su\n          1  2  3  4\n 5  6  7  8  9 10 11\n12 13 14 15 16 17 18\n19 20 21 22 23 24 25\n26 27 28 29\n```\n\n</details>\n\n- Try using one or more options in their \"long form\" (with `--`).\n  Why would those be useful?\n\n<details><summary>Solution</summary>\n\nFor example:\n\n```bash\ncal --julian --monday\n```\n```bash-out\n       February 2024       \nMon Tue Wed Thu Fri Sat Sun\n             32  33  34  35\n 36  37  38  39  40  41  42\n 43  44  45  46  47  48  49\n 50  51  52  53  54  55  56\n 57  58  59  60\n```\n\nThe advantage of using long options is that they are less cryptic and more descriptive.\nTherefore, it is much more likely that any reader of the code\n(including yourself next week) will immediately understand what these options are doing.\n\nNote that long options **cannot** be \"pasted together\" like short options.\n\n</details>\n\n- Bonus: Try to figure out / guess what the meaning is of the top of the help text:\n  `Usage: cal [options] [[[day] month] year]`.\n  Based on that, can you print a calendar for April 2017?\n\n<details><summary>Solution</summary>\n\nFirst of all, the square brackets around `options` and all of the possible arguments\nmeans that _none of these are required_ ---\nas we've seen, just `cal` (with no options or arguments) is a valid command.\n\nThe structure of the multiple square brackets around the day-month-year arguments indicate that:\n\n- _If_ you provide only one argument, it should be a year\n- _If_ you provide a second argument, it should be a month\n- _If_ you provide a third argument, it should be a day\n\nTherefore, to print a calendar for April 2017:\n\n```bash\ncal 4 2017\n```\n```bash-out\n     April 2017     \nSu Mo Tu We Th Fr Sa\n                   1\n 2  3  4  5  6  7  8\n 9 10 11 12 13 14 15\n16 17 18 19 20 21 22\n23 24 25 26 27 28 29\n30\n```\n\n</details>\n\n:::\n\n<br>\n\n## `cd`, paths, and shortcuts \n\n### `cd` and command \"actions\"\n\nAll the commands so far \"merely\" provided some information,\nwhich was printed to the screen.\n\nBut many commands perform another kind of **action**.\nFor example, the command **`cd`** will change your *working* directory.\nAnd like many commands that perform a potentially invisible action,\n`cd` normally has **no output** at all.\n\nFirst, let's check again where we are --- we should be in our Home directory:\n\n```bash\n# (Note: you will have a different PAS project listed in your Home dir. This is not important.)\npwd\n```\n```bash-out\n/users/PAS0471/jelmer\n```\n\nNow, let's use `cd` to move to another directory by specifying the *path* to that\ndirectory as an argument:\n\n``` bash\ncd /fs/ess/PAS2880\n```\n\n```bash\n# Double-check that we moved:\npwd\n```\n``` bash-out\n/fs/ess/PAS2880\n```\n\nIn summary:\n\n- Like `cal`, `cd` accepts an argument. Unlike `cal`, this argument takes the form\n  of a path that the command should operate on, which is much more typical.\n- `cd` gives no output when it successfully changed the working directory.\n  This is very common behavior for Unix commands that perform\n  operations: **when they succeed, they are silent**.\n\nLet's also see what happens when `cd` does not succeed — it gives an error:\n\n  ``` bash\n  cd /fs/ess/PAs2880\n  ```\n  \n  ``` bash-out\n  -bash: cd: /fs/ess/PAs2880: No such file or directory\n  ```\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: callout-note\n#### General shell tips\n\n-   Everything in the shell is **case-sensitive**, including commands and file names (hence the error above).\n-   Your **cursor** can be anywhere on a line (not just at the end) when you\n    press <kbd>Enter</kbd> to execute a command!\n-   Any text that comes after a **`#`** is considered a **comment** instead of code!\n    Comments are not executed but are ignored by the shell.\n\n``` bash\n# This entire line is a comment - you can run it and nothing will happen\npwd    # 'pwd' will be executed but everything after the '#' is ignored\n```\n\n``` bash-out\n/users/PAS0471/jelmer\n```\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Keyboard shortcuts\n\nUsing keyboard shortcuts help you work much more efficiently in the shell.\nAnd some are invaluable:\n\n-   **Cancel/stop/abort** --- If your prompt is \"missing\", the shell is still\n    busy executing your command, *or* you typed an incomplete command. To abort,\n    press <kbd>Ctrl</kbd>+<kbd>C</kbd> and you will get your prompt back.\n-   **Command history** --- `Up` / `Down` arrow keys to cycle through your command history.\n-   **Tab completion** --- The shell will auto-complete partial commands or file paths when you press <kbd>Tab</kbd>.\n\n::: exercise\n#### {{< fa user-edit >}} Practice with Tab completion & command history\n\n- Type **`/f`** and press <kbd>Tab</kbd> (will autocomplete to */fs/*)\n\n- Add **`e`** (*/fs/e*) and press <kbd>Tab</kbd> (will autocomplete to */fs/ess/*).\n\n- Add **`PAS`** (*/fs/ess/PAS*) and press <kbd>Tab</kbd>. Nothing should\n  happen: there are multiple (many!) options.\n\n- Press <kbd>Tab</kbd> <kbd>Tab</kbd> (i.e., twice in quick succession) and it should say:\n\n  ``` bash-out\n  Display all 619 possibilities? (y or n)\n  ```\n\n- Type `n` to answer no: we don't need to see all the dirs starting with `PAS`.\n\n- Add **`288`** (*/fs/ess/PAS27*) and press <kbd>Tab</kbd>\n  **twice in quick succession** (a single Tab won't do anything):\n  you should see at least four dirs that start with `PAS288`.\n\n- Add `0` so your line reads `/fs/ess/PAS2880`.\n  Press <kbd>Enter</kbd>. What does the resulting error mean?\n\n  ```bash-out-solo\n  bash: /fs/ess/PAS2880/: Is a directory\n  ```\n\n<details><summary>Click for the solution</summary>\nBasically, everything you type in the shell should start with a command.\nJust typing the name of a dir or file will not make the shell print some info about\nor the contents of said dir or file, as you perhaps expected.\n</details>\n\n- Press **<kbd>⇧</kbd>** to get the previous \"command\" back on the prompt.\n\n- Press **<kbd>Ctrl</kbd>+<kbd>A</kbd>** to move to the beginning of the line at once.\n\n- Add `cd` and a space in front of the dir, and press <kbd>Enter</kbd> again.\n\n  ```bash\n  cd /fs/ess/PAS2880/\n  ```\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: exercise\n#### {{< fa user-edit >}} Practice with canceling\n\nTo simulate a long-running command that we may want to abort, we can use the\n`sleep` command, which will make the computer wait for a specified amount of\ntime until giving your prompt back. Run the below command and instead of waiting\nfor the full 60 seconds, **press <kbd>Ctrl</kbd> + <kbd>C</kbd>** to get your prompt\nback sooner!\n\n``` bash\nsleep 60s\n```\n\nAs another example of a situation where you might have to use\n<kbd>Ctrl</kbd> + <kbd>C</kbd>,\nsimply type an opening parenthesis `(` and press <kbd>Enter</kbd>:\n\n``` bash\n(\n```\n\nWhen you do this, nothing is executed and you are not getting your prompt back:\nyou should see a `>` on the next line.\nThis is the shell wanting you to \"complete\" you command. Why would that be?\n\n<details><summary>Click for the solution</summary>\nThis is an incomplete command by definition because any opening parenthesis\nshould have a matching closing parenthesis.\n</details>\n\nPress <kbd>Ctrl</kbd> + <kbd>C</kbd> to get your regular prompt back.\n:::\n\n::: {.callout-note collapse=\"true\"}\n#### Table with useful keyboard shortcuts  _(Click to expand)_\n\n_(Note that even on Macs, you should use <kbd>Ctrl</kbd> instead of switching them_\n_out for <kbd>Cmd</kbd> as you may be used to doing --_\n_though in some cases, like copy/paste, both keys work)._\n\n| Shortcut | Function |\n|-----|------------|\n| <kbd>Tab</kbd> | Tab completion |\n| <kbd>⇧</kbd> / <kbd>⇩</kbd> | Cycle through previously issued commands | |\n| <kbd>Ctrl</kbd>(+<kbd>Shift</kbd>)+<kbd>C</kbd> | Copy selected text | |\n| <kbd>Ctrl</kbd>(+<kbd>Shift</kbd>)+<kbd>V</kbd> | Paste text from clipboard |\n| <kbd>Ctrl</kbd>+<kbd>A</kbd> / <kbd>Ctrl</kbd>+<kbd>E</kbd> | Go to beginning/end of line |\n| <kbd>Ctrl</kbd>+<kbd>U</kbd> /<kbd>Ctrl</kbd>+<kbd>K</kbd> | Cut from cursor to beginning / end of line |\n| <kbd>Ctrl</kbd>+<kbd>W</kbd> | ~~Cut word before before cursor~~ (Only works on Macs in our shell in the browser!) |\n| <kbd>Ctrl</kbd>+<kbd>Y</kbd> | Paste (\"yank\") text that was cut with one of the shortcuts above |\n| <kbd>Alt</kbd>+<kbd>.</kbd> / <kbd>Esc</kbd>+<kbd>.</kbd>  | Retrieve last argument of previous command (very useful!) (<kbd>Esc</kbd>+<kbd>.</kbd> for Mac) |\n| <kbd>Ctrl</kbd>+<kbd>R</kbd> | Search history: press <kbd>Ctrl</kbd>+<kbd>R</kbd> again to cycle through matches, <kbd>Enter</kbd> to put command in prompt. |\n| <kbd>Ctrl</kbd>+<kbd>C</kbd> | Cancel (kill/stop/abort) currently active command |\n| <kbd>Ctrl</kbd>+<kbd>D</kbd> | Exit (a program or the shell, depending on the context) (same as `exit` command) |\n| <kbd>Ctrl</kbd>+<kbd>L</kbd> | Clear the screen (same as `clear` command) |\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Environment variables\n\nYou may be familiar with the concept of **variables** from previous experience with perhaps R or another language.\nVariables can hold values and other pieces of data and are essential in programming.\n\n- Assigning and printing the value of a variable **in R**:\n\n\n\n  ::: {.cell}\n  \n  ```{.r .cell-code}\n  # (Don't run this)\n  x <- 5\n  x\n  ```\n  \n  ::: {.cell-output .cell-output-stdout}\n  \n  ``` styled-output\n  [1] 5\n  ```\n  \n  \n  :::\n  :::\n\n\n\n- Assigning and printing the value of a variable **in the Unix shell**:\n\n  ``` bash\n  x=5\n  echo $x\n  ```\n  ``` bash-out\n  5\n  ```\n\n::: callout-tip\n#### In the Unix shell code above, note that:\n\n-   There cannot be any **spaces** around the **`=`** in `x=5`.\n-   You need a **`$` prefix** to *reference* (but not to *assign*) variables in the shell[^4].\n-   You need the **`echo`** command, a general command to print text, to print the value of `$x` (cf. in R).\n\nBy the way, `echo` can also print literal text (as shown below) or combinations\nof literals and variables (next exercise):\n    \n```bash\necho \"Welcome to PLNTPTH 5004\"\n```\n```bash-out\nWelcome to PLNTPTH 5004\n```\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n:::\n\n[^4]: Because of this, anytime you see a word/string that starts with a `$` in the shell,\nyou can safely assume that it is a variable.\n\n**Environment variables** are pre-existing variables that have been automatically assigned values. Two examples:\n\n``` bash\n# $HOME contains the path to your Home dir:\necho $HOME\n```\n\n``` bash-out\n/users/PAS0471/jelmer\n```\n\n``` bash\n# $USER contains your user name:\necho $USER\n```\n\n``` bash-out\njelmer\n```\n\n::: exercise\n#### {{< fa user-edit >}} Exercise: environment variables\n\nUsing an environment variable, print \"_Hello, my name is \\<your username\\>_\" (e.g. \"Hello, my name is natalie\").\n\n<details><summary>*Click for the solution*</summary>\n\n``` bash\n# (This would also work without the \" \" quotes)\necho \"Hello, my name is $USER\"\n```\n\n``` bash-out\nHello, my name is jelmer\n```\n\n</details>\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Create your own dir & get the CSB data\n\nOur base OSC directory for the course is the **`/fs/ess/PAS2880`** dir we are currently in.\nNow, let's all create our own subdir in here, and get the data from the CSB book.\n\n-   Create a directory for yourself using the **`mkdir`** (**m**a**k**e **dir**) command:\n\n    ```bash\n    mkdir users/$USER\n    ```\n\n-   Move there using `cd`:\n\n    ```bash\n    # (Instead of $USER, you can also start typing your username and press Tab)\n    cd users/$USER\n    ```\n\n-   Get the files associated with the CSB book by \"*cloning*\" (downloading) its\n    GitHub repository:\n\n    ```bash\n    git clone https://github.com/CSB-book/CSB.git\n    ```\n\n-   Move into the *sandbox* dir for the Unix chapter (remember to use tab completion):\n\n    ```bash\n    cd CSB/unix/sandbox\n    ```\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n### Paths and path shortcuts\n\n#### Absolute (full) paths versus relative paths\n\nRecall from above that \"paths\" specify the location of a file or dir.\nAny file or dir can be referred to in two different ways, using either:\n\n- An **absolute (full) path** (e.g. `/fs/ess/PAS2880`) \\\n  A path that begin with a `/` starts from the computer's root directory,\n  and is called an \"absolute path\".\\\n  *(It is equivalent to GPS coordinates for a geographical location,*\n  *and works regardless of where you are*).\n\n- A **Relative path** (e.g. `CSB/unix/sandbox` or `todo_list.txt`)\\\n  A Path that starts from your current working directory is a \"relative path\".\\\n  *(It works like directions along the lines of \"take the second left:\"*\n  *it depends on your current location.)*\n\nNext week, we'll talk more about the distinction between absolute and relative paths,\nand their respective merits.\n\n<details><summary>In the example above, how can the file name `todo_list.txt` represent a path? _(Click for the solution)_</summary>\n\nA file name like `todo_list.txt`, with no directories included,\ncan be seen (and is often used!) as a relative path that implies that the file\nis in our current working dir.\n\nAlternatively, and often equivalently, you can be explicit about that\nby using a `./` preface, e.g.: `./todo_list.txt`\n(see the Path shortcuts section below).\n\n</details>\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n#### Path shortcuts\n\n- **`~`** (a tilde) --- represents your Home directory.\n  For example, `cd ~` moves you to your Home dir.\n- **`.`** (a single period) --- represents the current working directory\n  (we'll soon see how why that can be useful).\n- **`..`** (two periods) --- Represents the directory \"one level up\", i.e. towards the computer's root dir.\n\nSome examples of `..`:\n\n- Use `..` to go up one level in the dir hierarchy:\n\n  ```bash\n  pwd\n  ```\n  ```bash-out\n  /fs/ess/PAS2880/users/jelmer/CSB/unix/sandbox\n  ```\n  ```bash\n  cd ..\n  pwd\n  ```\n  ``` bash-out\n  /fs/ess/PAS2880/users/jelmer/CSB/unix\n  ```\n\n- This pattern can be continued all the way to the root of the computer,\n  so `../..` means two levels up:\n\n  ``` bash\n  cd ../..\n  pwd\n  ```\n  ``` bash-out\n  /fs/ess/PAS2880/users/jelmer\n  ```\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: callout-tip\n#### These path shortcuts work with many commands\nThese are *general shell shortcuts* that work with **any** command that accepts a path/file name.\n:::\n\n<hr style=\"height:1pt; visibility:hidden;\" />\n\n::: exercise\n#### {{< fa user-edit >}} Exercise: navigation\n\n- **A)** Use a relative path to move back to the `/fs/ess/PAS2880/users/$USER/CSB/unix/sandbox` dir.\n  (You should be in `/fs/ess/PAS2880/users/$USER`.)\n\n<details><summary>*(Click for the solution)*</summary>\n\n``` bash\ncd CSB/unix/sandbox\n```\n\n</details>\n\n- **B)** Use a relative path (with `..`) to move into the `/fs/ess/PAS2880/users/$USER/CSB/unix/data` dir.\n\n<details><summary>*(Click for the solution)*</summary>\n\n``` bash\ncd ../data\n```\n\nYou may have done this in two steps, because you may not have realized that you\ncan \"add to\" a path after `..` like we did above. So you may have done this:\n\n```bash\ncd ..\ncd data\n```\n\nThat's OK, but is obviously more typing.\n\n</details>\n\n- **C)** The `ls` command lists files and dirs, and accepts one or more paths as arguments.\n  Use `ls` to list the files in your Home dir with a shortcut and without moving there.\n\n<details><summary>*(Click for the solution)*</summary>\n\n- With the `~` shortcut:\n\n``` bash\nls ~\n# (Output not shown)\n```\n\n- With the `$HOME` environment variable:\n\n``` bash\nls $HOME\n# (Output not shown)\n```\n\n</details>\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}