---
title: "Unix Shell Basics"
pagetitle: "PRACS25: Shell Basics"
author: Jelmer Poelstra
date: 2025-09-02
editor_options: 
  chunk_output_type: console
---

--------------------------------------------------------------------------------

<br>

### Overview {-}

In this week's sessions,
we'll cover much of [CSB](https://library.ohio-state.edu/record=b8624007~S7)'s
Chapter 1 to learn:

- Why using a command-line interface can be beneficial.
- What the Unix shell is and what you can do with it. 
- Using the shell, how to:
  - Navigate around your computer.
  - Create and manage folders and files.
  - View text files.
  - Search within, manipulate, and extract information from text files.

::: callout-tip
#### See the ["Topic Overview" page on the Unix shell](../ref/shell.qmd) for an overview of shell commands we'll cover during this course.
:::

<br>

## Introduction to Unix and the Unix Shell

### Some terminology and concepts

#### Unix (vs. Linux)

We can conceptualize Unix (or "Unix-like" / "Unix-based")^[
_Technically_, the latter terms are more correct,
as Unix formally does refer to a specific operating system.]
as a **family of operating systems**, which includes Linux and Mac but not Windows.

For scientific computing, Unix-based operating systems are generally preferable.
Supercomputers, like the Ohio Supercomputer Center (OSC), use Linux.
In this course, though, your laptop/desktop can run on any operating system,
precisely because we will connect to OSC and do our work there.

#### Unix shell-related terms

-   **Command Line** and **Command Line Interface (CLI)** — A user interface where you type commands
-   **Shell** — a more specific and technical term for a command line interface _to your computer_
-   **Unix Shell** — the type of shell on Unix-based (Linux + Mac) computers
-   **Bash** — the specific Unix shell _language_ that is most common
-   **Terminal** — the program/app/window that can run a shell

While these are clearly not synonyms, in day-to-day computing,
they are often used interchangeably.

::: callout-note
#### CLI vs. GUI
Instead of a Command-line Interface (CLI),
most programs that we use on a day-to-day basis have a Graphical User Interface (GUI),
which are operated mostly by pointing and clicking rather than typing.
:::

<hr style="height:1pt; visibility:hidden;" />

### Why use the Unix shell?

The Unix shell has been around for a long time and can sometimes seem a bit
archaic.
But astonishingly, a system largely built decades ago in an era with very
different computers and datasets has stood the test of time,
and the ability to use it is a crucial skill in applied bioinformatics.

Specifically, you may want to or need to use the Unix shell as opposed to
programs with Graphical User Interfaces (GUIs) because of:

- **Software needs**\
  When working with omics data, we don't code our entire analysis from scratch --
  for example, we don't build our own genome assembly or read alignment algorithm.
  Many of the external tools that we use for this are run in the shell with
  a Command-Line Interface (CLI).
- **Automation and fewer errors**\
  The shell allows you to repeat and automate tasks easily and without
  introducing errors.
- **Reproducibility**\
  It's more straightforward to keep a detailed record of what you have done.
- **Working with large files**\
  Shell commands are really good at processing _large, plain-text files_,
  which are very common in omics data.
- **Remote computing – especially supercomputers**\
  It is often only possible to work in a shell when doing remote computing.

But what about versus other coding languages?
Why do we need to know the Unix shell on top of R and/or Python?

- **Efficiency**\
  For many _simpler_ tasks, built-in shell tools are faster ---
  in terms of coding time, processing time,
  and the ease of working with very large files.
- **Running external software**\
  As mentioned above,
  we need to use many external programs with a CLI in omics data analysis.
  While those _can_ be called from within other languages,
  the shell has a _direct_ interface to them and is therefore often preferred.

<hr style="height:1pt; visibility:hidden;" />

### The Unix directory structure

- "Directory" (or "**dir**" for short) is the term for *folder* that is commonly
  used in Unix contexts.
    
- The Unix directory structure is _hierarchical_,
  with a single starting point: the **root**, depicted as **`/`**.

- A "**path**" gives the location of a file or directory, in which directories
  are separated by forward slashes `/`.
    
- So: a leading `/` in a path is the root dir,
  and any subsequent `/` are used to separate dirs.
  For example, the path to our OSC project's dir is `/fs/ess/PAS2880`.
  This means: the dir `PAS2880` is located inside the dir `ess`, which in turn is
  inside the dir `fs`, which in turn is in the computer's root directory.

- The OSC dir structure is somewhat different from that of a personal computer.
  Our Home dir is not `/home/<username>` like in the book and the schematic
  on the left, but `/users/PASXXXX/<username>`.

::: columns
::: column
![Generic computer dir structure, from [O'Neil 2017](https://open.oregonstate.education/computationalbiology/chapter/the-command-line-and-filesystem/)](img/oneil_filesystem_ex2.png){fig-align="center" width="95%"}
:::
::: column
![Key dirs in the OSC dir structure](img/osc_dirstructure.png){fig-align="center" width="89%"}
:::
:::

<hr style="height:1pt; visibility:hidden;" />

::: exercise
#### {{< fa user-edit >}} Exercise: Figure out the path

In the above schematic on the left, what is the path to the file `todo_list.txt`?

<details><summary>Solution</summary>

The path to the file `todo_list.txt` is:
`/home/oneils/documents/todo_list.txt`

</details>
:::

<br>

## First steps in the shell

### Accessing a shell at OSC

1.  Go to <https://ondemand.osc.edu> in your browser, and log in.
2.  Click on the `Clusters` dropdown menu in the top bar and select
    `Cardinal Shell Access`.

### The shell's prompt

Inside your terminal, the "prompt" indicates that the shell is ready for a
command. What is shown exactly varies across shells and can also be customized,
but our prompts at OSC should show the following information:

`<username>@<node-name> <working-dir>]$`

For example (and _note that **`~`** means your Home dir_):

``` bash-in-nocolor
[jelmer@cardinal-login02 ~]$ 
```

We type our commands after the dollar sign `$`,
and then press <kbd>Enter</kbd> to execute the command.
When the command has finished executing,
we'll get our prompt back and are able to type and execute a new command.

::: callout-tip
#### Clear the screen with <kbd>Ctrl</kbd>+<kbd>L</kbd>
OSC prints welcome messages and storage quota information when you open a shell.
To reduce the amount of text on the screen, I will **clear** the screen now and regularly throughout.
This can be done with the keyboard shortcut **<kbd>Ctrl</kbd>+<kbd>L</kbd>**.

This is the first of a number of keyboard shortcuts you will learn,
as these are very useful when working in the shell.
:::

<hr style="height:1pt; visibility:hidden;" />

### A few simple commands: `date` and `pwd`

The Unix shell comes with hundreds of "commands":
small programs that perform specific actions.
(If you're familiar with R or Python, a Unix *command* is like an R/Python *function*.)

Let's start with a few simple commands:

-   The `date` command prints the current date and time:

    ``` bash
    date
    ```
    ``` bash-out
    Thu Feb 29 14:58:19 EST 2024
    ```

-   The `pwd` (Print Working Directory) command prints the path to the directory
    you are currently located in:

    ``` bash
    pwd
    ```
    ``` bash-out
    /users/PAS0471/jelmer
    ```

Both of those commands provided us with some output. That output was **printed
to screen**, which is the default behavior for nearly every Unix command.

<hr style="height:1pt; visibility:hidden;" />

::: callout-warning
#### Copying and pasting in this shell

You can't right-click in this shell, so to copy-and-paste:

-   **Copy** simply by selecting text
    (you should see a copy ({{< fa copy >}}) icon appear).
-   **Paste** using <kbd>Ctrl</kbd>+<kbd>V</kbd>.

{{< fa user-edit >}} Try copying and pasting a random word into your shell.
This may just work, you may get a permission pop-up, or it may silently fail ---
if the latter, click on the clipboard icon in your browser's address bar
(see red circle in screenshot below):

![](img/pasting2.png)
:::

<hr style="height:1pt; visibility:hidden;" />

## Options, arguments, and help

### The `cal` command --- and options & arguments

The `cal` command is another example of a command that simply prints some
information to the screen, in this case a calendar.
We'll use it to learn about command *options* and *arguments*.

Invoking `cal` without options or arguments will show a calendar for the current month:

```bash
cal
```
``` bash-out
    February 2024   
Su Mo Tu We Th Fr Sa
             1  2  3
 4  5  6  7  8  9 10
11 12 13 14 15 16 17
18 19 20 21 22 23 24
25 26 27 28 29
```

#### Option examples

Use the *option* `-j` (a dash `-` and then `j`) to instead get a Julian calendar,
in which day numbering is continuous instead of restarting each month:

```bash
# Make sure to leave a space between `cal` and `-j`!
cal -j
```
```bash-out
       February 2024       
Sun Mon Tue Wed Thu Fri Sat
                 32  33  34
 35  36  37  38  39  40  41
 42  43  44  45  46  47  48
 49  50  51  52  53  54  55
 56  57  58  59  60
```

Use the `-3` option to show 3 months (adding the previous and next month):

```bash
cal -3
```
``` bash-out
    January 2024          February 2024          March 2024     
Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa
    1  2  3  4  5  6               1  2  3                  1  2
 7  8  9 10 11 12 13   4  5  6  7  8  9 10   3  4  5  6  7  8  9
14 15 16 17 18 19 20  11 12 13 14 15 16 17  10 11 12 13 14 15 16
21 22 23 24 25 26 27  18 19 20 21 22 23 24  17 18 19 20 21 22 23
28 29 30 31           25 26 27 28 29        24 25 26 27 28 29 30
                                            31   
```

We can combine multiple options -- for example:

```bash
cal -j -3
```
``` bash-out
        January 2024                February 2024                  March 2024        
Sun Mon Tue Wed Thu Fri Sat  Sun Mon Tue Wed Thu Fri Sat  Sun Mon Tue Wed Thu Fri Sat
      1   2   3   4   5   6                   32  33  34                       61  62
  7   8   9  10  11  12  13   35  36  37  38  39  40  41   63  64  65  66  67  68  69
 14  15  16  17  18  19  20   42  43  44  45  46  47  48   70  71  72  73  74  75  76
 21  22  23  24  25  26  27   49  50  51  52  53  54  55   77  78  79  80  81  82  83
 28  29  30  31               56  57  58  59  60           84  85  86  87  88  89  90
                                                           91 
```

Handily, options can be "pasted together" like so (output not shown - same as above):

```bash
cal -j3
```

#### Options summary

As we've seen, options are specified with a dash `-`
(or to dashes `--`, as you'll see later).
So far, we've only worked with the type of options that are also called "**flags**",
_which change some functionality in an ON/OFF type way_:

- Turning a Julian calender display ON with `-j`
- Turning a 3-month display ON with `-3`.

Generally speaking, we can say that options **change the behavior** of a command.

#### Arguments

Whereas options change the behavior of a command,
arguments typically tell the command **what to operate on**.
Most commonly, these are file or directory paths.

Admittedly, the `cal` command is not the best illustration of this pattern ---
when you give it one argument, this should be the year to show a calendar for:

```bash
cal 2020
```
```bash-out
                              2020                               

       January               February                 March       
Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa
          1  2  3  4                      1    1  2  3  4  5  6  7
 5  6  7  8  9 10 11    2  3  4  5  6  7  8    8  9 10 11 12 13 14
12 13 14 15 16 17 18    9 10 11 12 13 14 15   15 16 17 18 19 20 21
19 20 21 22 23 24 25   16 17 18 19 20 21 22   22 23 24 25 26 27 28
26 27 28 29 30 31      23 24 25 26 27 28 29   29 30 31

# [...output truncated, entire year is shown...]
```

We'll see some examples of commands operating on files or dirs later.
Finally, we can also _combine_ options and arguments:

```bash
cal -j 2020
```
```bash-out
                            2020                          

          January                       February         
Sun Mon Tue Wed Thu Fri Sat   Sun Mon Tue Wed Thu Fri Sat
              1   2   3   4                            32
  5   6   7   8   9  10  11    33  34  35  36  37  38  39
 12  13  14  15  16  17  18    40  41  42  43  44  45  46
 19  20  21  22  23  24  25    47  48  49  50  51  52  53
 26  27  28  29  30  31        54  55  56  57  58  59  60
 
# [...output truncated, entire year is shown...]
```
  
To summarize, different from options, _arguments_ to a command:

- Are not preceded by a `-` (or `--`)
- If options and arguments are combined, arguments **come after** options^[
  Though some commands are flexible and accept either order.].

::: callout-warning
#### TBA: Command structure visualization
:::

<hr style="height:1pt; visibility:hidden;" />

### Getting help

Many basic Unix commands – *and other command-line programs!* –
have a **`-h`** option for help,
which usually gives a concise summary of the command's "syntax",
i.e. its available options and arguments:

```bash
cal -h
```
```bash-out

Usage:
 cal [options] [[[day] month] year]

Options:
 -1, --one        show only current month (default)
 -3, --three      show previous, current and next month
 -s, --sunday     Sunday as first day of week
 -m, --monday     Monday as first day of week
 -j, --julian     output Julian dates
 -y, --year       show whole current year
 -V, --version    display version information and exit
 -h, --help       display this help text and exit
```

In this case, each option can be referred to in two ways:

- A short-form notation: a single dash followed by a single character (e.g. `-s`)
- A long-form notation: two dashes followed by a word (e.g. `--sunday`)

::: {.callout-note collapse="true"}
### Another way to see documentation: the `man` command _(Click to expand)_
An alternative way of getting help for Unix commands is with the `man` command:

```bash
man cal
```

This manual page often includes a lot more details than the `--help` output,
and it is opened inside a "pager" rather than printed to screen:
type **<kbd>q</kbd>** to exit the pager that `man` launches.

:::

::: exercise
#### {{< fa user-edit >}} Exercise: Interpreting the help output

- Look through the options listed when you ran `cal -h`, and try an option we
  haven't used yet.
  (You can also combine this new option with other options, if you want.)

<details><summary>Solution</summary>

```bash
# Print a calendar with Monday as the first day of th week (instead of the default, Sunday) 
cal -m
```
```bash-out
    February 2024   
Mo Tu We Th Fr Sa Su
          1  2  3  4
 5  6  7  8  9 10 11
12 13 14 15 16 17 18
19 20 21 22 23 24 25
26 27 28 29
```

</details>

- Try using one or more options in their "long form" (with `--`).
  Why would those be useful?

<details><summary>Solution</summary>

For example:

```bash
cal --julian --monday
```
```bash-out
       February 2024       
Mon Tue Wed Thu Fri Sat Sun
             32  33  34  35
 36  37  38  39  40  41  42
 43  44  45  46  47  48  49
 50  51  52  53  54  55  56
 57  58  59  60
```

The advantage of using long options is that they are less cryptic and more descriptive.
Therefore, it is much more likely that any reader of the code
(including yourself next week) will immediately understand what these options are doing.

Note that long options **cannot** be "pasted together" like short options.

</details>

- Bonus: Try to figure out / guess what the meaning is of the top of the help text:
  `Usage: cal [options] [[[day] month] year]`.
  Based on that, can you print a calendar for April 2017?

<details><summary>Solution</summary>

First of all, the square brackets around `options` and all of the possible arguments
means that _none of these are required_ ---
as we've seen, just `cal` (with no options or arguments) is a valid command.

The structure of the multiple square brackets around the day-month-year arguments indicate that:

- _If_ you provide only one argument, it should be a year
- _If_ you provide a second argument, it should be a month
- _If_ you provide a third argument, it should be a day

Therefore, to print a calendar for April 2017:

```bash
cal 4 2017
```
```bash-out
     April 2017     
Su Mo Tu We Th Fr Sa
                   1
 2  3  4  5  6  7  8
 9 10 11 12 13 14 15
16 17 18 19 20 21 22
23 24 25 26 27 28 29
30
```

</details>

:::

<br>

## `cd`, paths, and shortcuts 

### `cd` and command "actions"

All the commands so far "merely" provided some information,
which was printed to the screen.

But many commands perform another kind of **action**.
For example, the command **`cd`** will change your *working* directory.
And like many commands that perform a potentially invisible action,
`cd` normally has **no output** at all.

First, let's check again where we are --- we should be in our Home directory:

```bash
# (Note: you will have a different PAS project listed in your Home dir. This is not important.)
pwd
```
```bash-out
/users/PAS0471/jelmer
```

Now, let's use `cd` to move to another directory by specifying the *path* to that
directory as an argument:

``` bash
cd /fs/ess/PAS2880
```

```bash
# Double-check that we moved:
pwd
```
``` bash-out
/fs/ess/PAS2880
```

In summary:

- Like `cal`, `cd` accepts an argument. Unlike `cal`, this argument takes the form
  of a path that the command should operate on, which is much more typical.
- `cd` gives no output when it successfully changed the working directory.
  This is very common behavior for Unix commands that perform
  operations: **when they succeed, they are silent**.

Let's also see what happens when `cd` does not succeed — it gives an error:

  ``` bash
  cd /fs/ess/PAs2880
  ```
  
  ``` bash-out
  -bash: cd: /fs/ess/PAs2880: No such file or directory
  ```

<hr style="height:1pt; visibility:hidden;" />

::: callout-note
#### General shell tips

-   Everything in the shell is **case-sensitive**, including commands and file names (hence the error above).
-   Your **cursor** can be anywhere on a line (not just at the end) when you
    press <kbd>Enter</kbd> to execute a command!
-   Any text that comes after a **`#`** is considered a **comment** instead of code!
    Comments are not executed but are ignored by the shell.

``` bash
# This entire line is a comment - you can run it and nothing will happen
pwd    # 'pwd' will be executed but everything after the '#' is ignored
```

``` bash-out
/users/PAS0471/jelmer
```

<hr style="height:1pt; visibility:hidden;" />
:::

<hr style="height:1pt; visibility:hidden;" />

### Keyboard shortcuts

Using keyboard shortcuts help you work much more efficiently in the shell.
And some are invaluable:

-   **Cancel/stop/abort** --- If your prompt is "missing", the shell is still
    busy executing your command, *or* you typed an incomplete command. To abort,
    press <kbd>Ctrl</kbd>+<kbd>C</kbd> and you will get your prompt back.
-   **Command history** --- `Up` / `Down` arrow keys to cycle through your command history.
-   **Tab completion** --- The shell will auto-complete partial commands or file paths when you press <kbd>Tab</kbd>.

::: exercise
#### {{< fa user-edit >}} Practice with Tab completion & command history

- Type **`/f`** and press <kbd>Tab</kbd> (will autocomplete to */fs/*)

- Add **`e`** (*/fs/e*) and press <kbd>Tab</kbd> (will autocomplete to */fs/ess/*).

- Add **`PAS`** (*/fs/ess/PAS*) and press <kbd>Tab</kbd>. Nothing should
  happen: there are multiple (many!) options.

- Press <kbd>Tab</kbd> <kbd>Tab</kbd> (i.e., twice in quick succession) and it should say:

  ``` bash-out
  Display all 619 possibilities? (y or n)
  ```

- Type `n` to answer no: we don't need to see all the dirs starting with `PAS`.

- Add **`288`** (*/fs/ess/PAS27*) and press <kbd>Tab</kbd>
  **twice in quick succession** (a single Tab won't do anything):
  you should see at least four dirs that start with `PAS288`.

- Add `0` so your line reads `/fs/ess/PAS2880`.
  Press <kbd>Enter</kbd>. What does the resulting error mean?

  ```bash-out-solo
  bash: /fs/ess/PAS2880/: Is a directory
  ```

<details><summary>Click for the solution</summary>
Basically, everything you type in the shell should start with a command.
Just typing the name of a dir or file will not make the shell print some info about
or the contents of said dir or file, as you perhaps expected.
</details>

- Press **<kbd>⇧</kbd>** to get the previous "command" back on the prompt.

- Press **<kbd>Ctrl</kbd>+<kbd>A</kbd>** to move to the beginning of the line at once.

- Add `cd` and a space in front of the dir, and press <kbd>Enter</kbd> again.

  ```bash
  cd /fs/ess/PAS2880/
  ```
:::

<hr style="height:1pt; visibility:hidden;" />

::: exercise
#### {{< fa user-edit >}} Practice with canceling

To simulate a long-running command that we may want to abort, we can use the
`sleep` command, which will make the computer wait for a specified amount of
time until giving your prompt back. Run the below command and instead of waiting
for the full 60 seconds, **press <kbd>Ctrl</kbd> + <kbd>C</kbd>** to get your prompt
back sooner!

``` bash
sleep 60s
```

As another example of a situation where you might have to use
<kbd>Ctrl</kbd> + <kbd>C</kbd>,
simply type an opening parenthesis `(` and press <kbd>Enter</kbd>:

``` bash
(
```

When you do this, nothing is executed and you are not getting your prompt back:
you should see a `>` on the next line.
This is the shell wanting you to "complete" you command. Why would that be?

<details><summary>Click for the solution</summary>
This is an incomplete command by definition because any opening parenthesis
should have a matching closing parenthesis.
</details>

Press <kbd>Ctrl</kbd> + <kbd>C</kbd> to get your regular prompt back.
:::

::: {.callout-note collapse="true"}
#### Table with useful keyboard shortcuts  _(Click to expand)_

_(Note that even on Macs, you should use <kbd>Ctrl</kbd> instead of switching them_
_out for <kbd>Cmd</kbd> as you may be used to doing --_
_though in some cases, like copy/paste, both keys work)._

| Shortcut | Function |
|-----|------------|
| <kbd>Tab</kbd> | Tab completion |
| <kbd>⇧</kbd> / <kbd>⇩</kbd> | Cycle through previously issued commands | |
| <kbd>Ctrl</kbd>(+<kbd>Shift</kbd>)+<kbd>C</kbd> | Copy selected text | |
| <kbd>Ctrl</kbd>(+<kbd>Shift</kbd>)+<kbd>V</kbd> | Paste text from clipboard |
| <kbd>Ctrl</kbd>+<kbd>A</kbd> / <kbd>Ctrl</kbd>+<kbd>E</kbd> | Go to beginning/end of line |
| <kbd>Ctrl</kbd>+<kbd>U</kbd> /<kbd>Ctrl</kbd>+<kbd>K</kbd> | Cut from cursor to beginning / end of line |
| <kbd>Ctrl</kbd>+<kbd>W</kbd> | ~~Cut word before before cursor~~ (Only works on Macs in our shell in the browser!) |
| <kbd>Ctrl</kbd>+<kbd>Y</kbd> | Paste ("yank") text that was cut with one of the shortcuts above |
| <kbd>Alt</kbd>+<kbd>.</kbd> / <kbd>Esc</kbd>+<kbd>.</kbd>  | Retrieve last argument of previous command (very useful!) (<kbd>Esc</kbd>+<kbd>.</kbd> for Mac) |
| <kbd>Ctrl</kbd>+<kbd>R</kbd> | Search history: press <kbd>Ctrl</kbd>+<kbd>R</kbd> again to cycle through matches, <kbd>Enter</kbd> to put command in prompt. |
| <kbd>Ctrl</kbd>+<kbd>C</kbd> | Cancel (kill/stop/abort) currently active command |
| <kbd>Ctrl</kbd>+<kbd>D</kbd> | Exit (a program or the shell, depending on the context) (same as `exit` command) |
| <kbd>Ctrl</kbd>+<kbd>L</kbd> | Clear the screen (same as `clear` command) |
:::

<hr style="height:1pt; visibility:hidden;" />

### Environment variables

You may be familiar with the concept of **variables** from previous experience with perhaps R or another language.
Variables can hold values and other pieces of data and are essential in programming.

- Assigning and printing the value of a variable **in R**:

  ```{r, eval=TRUE}
  #| class-output: styled-output
  # (Don't run this)
  x <- 5
  x
  ```

- Assigning and printing the value of a variable **in the Unix shell**:

  ``` bash
  x=5
  echo $x
  ```
  ``` bash-out
  5
  ```

::: callout-tip
#### In the Unix shell code above, note that:

-   There cannot be any **spaces** around the **`=`** in `x=5`.
-   You need a **`$` prefix** to *reference* (but not to *assign*) variables in the shell[^4].
-   You need the **`echo`** command, a general command to print text, to print the value of `$x` (cf. in R).

By the way, `echo` can also print literal text (as shown below) or combinations
of literals and variables (next exercise):
    
```bash
echo "Welcome to PLNTPTH 5004"
```
```bash-out
Welcome to PLNTPTH 5004
```

<hr style="height:1pt; visibility:hidden;" />

:::

[^4]: Because of this, anytime you see a word/string that starts with a `$` in the shell,
you can safely assume that it is a variable.

**Environment variables** are pre-existing variables that have been automatically assigned values. Two examples:

``` bash
# $HOME contains the path to your Home dir:
echo $HOME
```

``` bash-out
/users/PAS0471/jelmer
```

``` bash
# $USER contains your user name:
echo $USER
```

``` bash-out
jelmer
```

::: exercise
#### {{< fa user-edit >}} Exercise: environment variables

Using an environment variable, print "_Hello, my name is \<your username\>_" (e.g. "Hello, my name is natalie").

<details><summary>*Click for the solution*</summary>

``` bash
# (This would also work without the " " quotes)
echo "Hello, my name is $USER"
```

``` bash-out
Hello, my name is jelmer
```

</details>
:::

<hr style="height:1pt; visibility:hidden;" />

### Create your own dir & get the CSB data

Our base OSC directory for the course is the **`/fs/ess/PAS2880`** dir we are currently in.
Now, let's all create our own subdir in here, and get the data from the CSB book.

-   Create a directory for yourself using the **`mkdir`** (**m**a**k**e **dir**) command:

    ```bash
    mkdir users/$USER
    ```

-   Move there using `cd`:

    ```bash
    # (Instead of $USER, you can also start typing your username and press Tab)
    cd users/$USER
    ```

-   Get the files associated with the CSB book by "*cloning*" (downloading) its
    GitHub repository:

    ```bash
    git clone https://github.com/CSB-book/CSB.git
    ```

-   Move into the *sandbox* dir for the Unix chapter (remember to use tab completion):

    ```bash
    cd CSB/unix/sandbox
    ```

<hr style="height:1pt; visibility:hidden;" />

### Paths and path shortcuts

#### Absolute (full) paths versus relative paths

Recall from above that "paths" specify the location of a file or dir.
Any file or dir can be referred to in two different ways, using either:

- An **absolute (full) path** (e.g. `/fs/ess/PAS2880`) \
  A path that begin with a `/` starts from the computer's root directory,
  and is called an "absolute path".\
  *(It is equivalent to GPS coordinates for a geographical location,*
  *and works regardless of where you are*).

- A **Relative path** (e.g. `CSB/unix/sandbox` or `todo_list.txt`)\
  A Path that starts from your current working directory is a "relative path".\
  *(It works like directions along the lines of "take the second left:"*
  *it depends on your current location.)*

Next week, we'll talk more about the distinction between absolute and relative paths,
and their respective merits.

<details><summary>In the example above, how can the file name `todo_list.txt` represent a path? _(Click for the solution)_</summary>

A file name like `todo_list.txt`, with no directories included,
can be seen (and is often used!) as a relative path that implies that the file
is in our current working dir.

Alternatively, and often equivalently, you can be explicit about that
by using a `./` preface, e.g.: `./todo_list.txt`
(see the Path shortcuts section below).

</details>

<hr style="height:1pt; visibility:hidden;" />

#### Path shortcuts

- **`~`** (a tilde) --- represents your Home directory.
  For example, `cd ~` moves you to your Home dir.
- **`.`** (a single period) --- represents the current working directory
  (we'll soon see how why that can be useful).
- **`..`** (two periods) --- Represents the directory "one level up", i.e. towards the computer's root dir.

Some examples of `..`:

- Use `..` to go up one level in the dir hierarchy:

  ```bash
  pwd
  ```
  ```bash-out
  /fs/ess/PAS2880/users/jelmer/CSB/unix/sandbox
  ```
  ```bash
  cd ..
  pwd
  ```
  ``` bash-out
  /fs/ess/PAS2880/users/jelmer/CSB/unix
  ```

- This pattern can be continued all the way to the root of the computer,
  so `../..` means two levels up:

  ``` bash
  cd ../..
  pwd
  ```
  ``` bash-out
  /fs/ess/PAS2880/users/jelmer
  ```

<hr style="height:1pt; visibility:hidden;" />

::: callout-tip
#### These path shortcuts work with many commands
These are *general shell shortcuts* that work with **any** command that accepts a path/file name.
:::

<hr style="height:1pt; visibility:hidden;" />

::: exercise
#### {{< fa user-edit >}} Exercise: navigation

- **A)** Use a relative path to move back to the `/fs/ess/PAS2880/users/$USER/CSB/unix/sandbox` dir.
  (You should be in `/fs/ess/PAS2880/users/$USER`.)

<details><summary>*(Click for the solution)*</summary>

``` bash
cd CSB/unix/sandbox
```

</details>

- **B)** Use a relative path (with `..`) to move into the `/fs/ess/PAS2880/users/$USER/CSB/unix/data` dir.

<details><summary>*(Click for the solution)*</summary>

``` bash
cd ../data
```

You may have done this in two steps, because you may not have realized that you
can "add to" a path after `..` like we did above. So you may have done this:

```bash
cd ..
cd data
```

That's OK, but is obviously more typing.

</details>

- **C)** The `ls` command lists files and dirs, and accepts one or more paths as arguments.
  Use `ls` to list the files in your Home dir with a shortcut and without moving there.

<details><summary>*(Click for the solution)*</summary>

- With the `~` shortcut:

``` bash
ls ~
# (Output not shown)
```

- With the `$HOME` environment variable:

``` bash
ls $HOME
# (Output not shown)
```

</details>
:::
